# EventsCV + Luma: Plano PragmÃ¡tico de Features Essenciais

## ğŸ“‹ SumÃ¡rio Executivo

**Objetivo:** Adicionar as MELHORES features do Luma ao Events.cv de forma pragmÃ¡tica e executÃ¡vel, aproveitando o que jÃ¡ temos e focando em **alto impacto com esforÃ§o controlado**.

**Abordagem:** Matriz Impacto vs EsforÃ§o para priorizar features
**IntegraÃ§Ã£o:** n8n.pagali.ai (nÃ£o Zapier) + Zoom
**Timeline:** 3-4 meses (ao invÃ©s de 9-12)
**Investimento:** â‚¬30,000 - â‚¬45,000 (ao invÃ©s de â‚¬120k)

---

## ğŸ¯ AnÃ¡lise: O Que JÃ Temos (Vantagens Competitivas)

### âœ… Features Ãšnicas do Events.cv que Luma NÃƒO TEM

1. **NFC Wristbands & Cashless Payments** ğŸ’ª
   - Sistema completo de pulseiras NFC
   - Pagamentos cashless em eventos
   - Vendor management
   - Transaction tracking offline/online

2. **Digital Wallet System** ğŸ’³
   - User wallet com balance
   - Top-up system
   - Bonus balance
   - Transaction history

3. **Loyalty Program** â­
   - Loyalty points e tiers (bronze, silver, gold, platinum)
   - Reward system
   - Referral program infrastructure
   - Gamification

4. **Local Payment Integration** ğŸŒ
   - Pagali (Cape Verde mobile money)
   - Vinti4 (Cape Verde cards)
   - MB WAY (Portugal)
   - Stripe (internacional)

5. **QR Registration System** ğŸ“±
   - QR code para guest registration
   - Custom fields
   - Demographics collection
   - Source tracking (web, QR, social)

6. **Multi-Tenant SaaS Architecture** ğŸ¢
   - Organizations com subscriptions
   - Plans com limits
   - Platform role system
   - Commission management

7. **Advanced Team Management** ğŸ‘¥
   - Granular permissions
   - Role-based access
   - Event-scoped access
   - Invitation system

8. **Super-Admin Platform** ğŸ› ï¸
   - Platform-wide analytics
   - Organization management
   - User verification
   - Payout approval

**CONCLUSÃƒO:** JÃ¡ temos uma base SÃ“LIDA. Luma Ã© forte em **comunidade e engagement**, precisamos adicionar isso.

---

## ğŸ” Matriz Impacto vs EsforÃ§o: TOP Features do Luma

### QUADRANTE 1: ğŸš€ ALTO IMPACTO + BAIXO ESFORÃ‡O (Implementar AGORA)

| # | Feature | Impacto | EsforÃ§o | BenefÃ­cio |
|---|---------|---------|---------|-----------|
| 1 | **Event Calendars** | ğŸ”¥ğŸ”¥ğŸ”¥ | âš™ï¸âš™ï¸ | Eventos recorrentes, comunidade, subscribers |
| 2 | **Guest Chat** | ğŸ”¥ğŸ”¥ğŸ”¥ | âš™ï¸âš™ï¸ | Networking, engagement, retenÃ§Ã£o |
| 3 | **Event Blasts (Email/SMS)** | ğŸ”¥ğŸ”¥ğŸ”¥ | âš™ï¸âš™ï¸ | ComunicaÃ§Ã£o em massa, reminders |
| 4 | **Event Themes & Templates** | ğŸ”¥ğŸ”¥ | âš™ï¸ | UX melhorado, pÃ¡ginas lindas |
| 5 | **Add to Calendar** | ğŸ”¥ğŸ”¥ | âš™ï¸ | Conversion, user retention |
| 6 | **Social Sharing (OG tags)** | ğŸ”¥ğŸ”¥ğŸ”¥ | âš™ï¸ | Viral growth, descoberta |
| 7 | **Waitlist Management** | ğŸ”¥ğŸ”¥ | âš™ï¸âš™ï¸ | Captura demanda, FOMO |
| 8 | **Registration Questions** | ğŸ”¥ğŸ”¥ | âš™ï¸ | Dados customizados, segmentaÃ§Ã£o |

### QUADRANTE 2: ğŸ¯ ALTO IMPACTO + MÃ‰DIO ESFORÃ‡O (Implementar DEPOIS)

| # | Feature | Impacto | EsforÃ§o | BenefÃ­cio |
|---|---------|---------|---------|-----------|
| 9 | **Zoom Integration** | ğŸ”¥ğŸ”¥ğŸ”¥ | âš™ï¸âš™ï¸âš™ï¸ | Eventos virtuais, automaÃ§Ã£o |
| 10 | **n8n Integration** | ğŸ”¥ğŸ”¥ğŸ”¥ | âš™ï¸âš™ï¸âš™ï¸ | Workflows, automaÃ§Ã£o, conectividade |
| 11 | **Event Discovery Feed** | ğŸ”¥ğŸ”¥ğŸ”¥ | âš™ï¸âš™ï¸âš™ï¸ | Crescimento orgÃ¢nico, SEO |
| 12 | **Calendar Newsletters** | ğŸ”¥ğŸ”¥ | âš™ï¸âš™ï¸ | Engagement, community building |
| 13 | **Post-Event Surveys** | ğŸ”¥ğŸ”¥ | âš™ï¸âš™ï¸ | Feedback, melhoria contÃ­nua |
| 14 | **Event Cloning** | ğŸ”¥ğŸ”¥ | âš™ï¸âš™ï¸ | Produtividade organizers |

### QUADRANTE 3: ğŸ’¡ MÃ‰DIO IMPACTO + BAIXO ESFORÃ‡O (Nice to Have)

| # | Feature | Impacto | EsforÃ§o | BenefÃ­cio |
|---|---------|---------|---------|-----------|
| 15 | **Unlock Codes** | ğŸ”¥ | âš™ï¸ | Secret tickets, exclusividade |
| 16 | **Guest Profiles** | ğŸ”¥ | âš™ï¸ | Networking, social |
| 17 | **Rich Text Editor** | ğŸ”¥ | âš™ï¸ | ConteÃºdo formatado |
| 18 | **Cover Image Gallery** | ğŸ”¥ | âš™ï¸ | Stock photos curadas |

### QUADRANTE 4: â¸ï¸ BAIXO IMPACTO ou ALTO ESFORÃ‡O (NÃƒO Implementar Agora)

- Crypto payments (complexo, baixo mercado)
- Token gating (nicho demais)
- Okta SSO (sÃ³ enterprise)
- Public API completa (usar n8n)
- Passkeys (ainda cedo)
- WhatsApp integration (caro, regulado)

---

## ğŸ—ï¸ Roadmap PragmÃ¡tico: 3 Fases em 3-4 Meses

### **FASE 1: Foundation & Quick Wins** (4-5 semanas)
**Objetivo:** Features de alto impacto e baixo esforÃ§o

#### Semana 1-2: Event Themes & Social Sharing
**EsforÃ§o:** Baixo | **Impacto:** Alto

**Features:**
- [ ] Event theme selector (3-5 presets: default, minimal, vibrant, elegant, dark)
- [ ] Theme customization (colors, fonts)
- [ ] Open Graph meta tags optimization
- [ ] Dynamic OG image generation (event poster)
- [ ] Twitter card tags
- [ ] Add to Calendar button (iOS/Android/Google)

**Shared Types:**
```typescript
// packages/shared-types/src/event.ts
interface EventTheme {
  preset: 'default' | 'minimal' | 'vibrant' | 'elegant' | 'dark';
  primaryColor: string;
  backgroundColor: string;
  fontFamily: string;
}

// Add to Event interface
interface Event {
  // ... existing fields
  theme?: EventTheme;
}
```

**Frontend:**
```typescript
// apps/web/components/event/ThemeSelector.tsx
export function ThemeSelector({ eventId, currentTheme, onChange }) {
  const themes = [
    { id: 'default', name: 'PadrÃ£o', colors: {...} },
    { id: 'minimal', name: 'Minimalista', colors: {...} },
    // ...
  ];
  return <div>Theme selector UI</div>;
}

// apps/web/components/event/AddToCalendar.tsx
export function AddToCalendar({ event }) {
  const generateICS = () => { /* ICS file generation */ };
  const addToGoogleCalendar = () => { /* Google Calendar link */ };
  return <div>Add to calendar dropdown</div>;
}
```

**Backend:**
```typescript
// functions/src/events/generateOGImage.ts
export const generateOGImage = functions.https.onCall(async (data, context) => {
  // Use sharp or canvas to generate image
  // Upload to Cloud Storage
  // Return URL
});
```

#### Semana 3: Registration Questions & Waitlist
**EsforÃ§o:** Baixo-MÃ©dio | **Impacto:** Alto

**Features:**
- [ ] Custom registration questions builder
- [ ] Question types: text, email, phone, select, checkbox
- [ ] Required/optional fields
- [ ] Waitlist auto-enrollment when sold out
- [ ] Waitlist notification quando tickets disponÃ­veis

**Shared Types:**
```typescript
// packages/shared-types/src/event.ts
interface RegistrationQuestion {
  id: string;
  type: 'text' | 'email' | 'phone' | 'select' | 'checkbox' | 'textarea';
  question: string;
  options?: string[];
  required: boolean;
  order: number;
}

interface Event {
  // ... existing
  registrationQuestions?: RegistrationQuestion[];
  waitlistEnabled: boolean;
  waitlistCapacity?: number;
}

// packages/shared-types/src/waitlist.ts
interface WaitlistEntry {
  id: string;
  eventId: string;
  userId?: string;
  email: string;
  name: string;
  position: number;
  notified: boolean;
  notifiedAt?: Date;
  expiresAt?: Date;
  createdAt: Date;
}
```

**Collections:**
```
/waitlists/{entryId}
  - eventId
  - userId
  - email, name
  - position
  - notified, notifiedAt
  - expiresAt
```

**Cloud Functions:**
```typescript
// functions/src/waitlist/onTicketAvailable.ts
export const onTicketAvailable = functions.firestore
  .document('ticket_types/{ticketTypeId}')
  .onUpdate(async (change, context) => {
    const before = change.before.data();
    const after = change.after.data();

    // Check if tickets became available
    const beforeAvailable = before.quantityTotal - before.quantitySold;
    const afterAvailable = after.quantityTotal - after.quantitySold;

    if (beforeAvailable === 0 && afterAvailable > 0) {
      // Notify waitlist
      const waitlist = await getWaitlistEntries(after.eventId);
      const toNotify = waitlist.slice(0, afterAvailable);

      for (const entry of toNotify) {
        await sendWaitlistNotification(entry);
        await markAsNotified(entry.id);
      }
    }
  });
```

#### Semana 4-5: Event Calendars
**EsforÃ§o:** MÃ©dio | **Impacto:** Muito Alto

**Features:**
- [ ] Calendar CRUD (create, read, update, delete)
- [ ] Calendar public page
- [ ] Subscribe/unsubscribe to calendars
- [ ] List events in calendar
- [ ] Calendar subscribers count
- [ ] Calendar visibility (public/private/unlisted)

**Shared Types:**
```typescript
// packages/shared-types/src/calendar.ts
interface Calendar {
  id: string;
  organizationId: string;
  name: string;
  slug: string;
  description: string;
  coverImage?: string;
  visibility: 'public' | 'private' | 'unlisted';
  subscriberCount: number;
  eventCount: number;
  settings: {
    allowMemberEvents: boolean;
    requireApproval: boolean;
  };
  createdAt: Date;
  updatedAt: Date;
}

interface CalendarSubscriber {
  id: string;
  calendarId: string;
  userId: string;
  subscribedAt: Date;
  emailNotifications: boolean;
  pushNotifications: boolean;
}
```

**Collections:**
```
/calendars/{calendarId}
/calendar_subscribers/{subscriberId}
```

**Add to Event:**
```typescript
interface Event {
  // ... existing
  calendarId?: string;
}
```

**Frontend:**
```typescript
// apps/web/app/calendars/[slug]/page.tsx
export default function CalendarPage({ params }) {
  const { calendar, events, isSubscribed } = useCalendar(params.slug);

  return (
    <div>
      <CalendarHeader calendar={calendar} />
      <SubscribeButton
        calendarId={calendar.id}
        isSubscribed={isSubscribed}
      />
      <EventList events={events} />
    </div>
  );
}

// apps/admin/app/calendars/page.tsx
export default function CalendarsPage() {
  return <CalendarManagement />;
}
```

**Cloud Functions:**
```typescript
// functions/src/calendars/onSubscribe.ts
export const onSubscribe = functions.firestore
  .document('calendar_subscribers/{subscriberId}')
  .onCreate(async (snap, context) => {
    const subscriber = snap.data();

    // Increment subscriber count
    await db.collection('calendars').doc(subscriber.calendarId).update({
      subscriberCount: admin.firestore.FieldValue.increment(1)
    });

    // Send welcome email
    await sendCalendarWelcomeEmail(subscriber);
  });
```

---

### **FASE 2: Communication & Engagement** (4-5 semanas)
**Objetivo:** Aumentar engagement drasticamente

#### Semana 6-7: Event Blasts (Email/SMS/Push)
**EsforÃ§o:** MÃ©dio | **Impacto:** Muito Alto

**Features:**
- [ ] Blast composer (email, SMS, push)
- [ ] Recipient filtering (all, registered, checked-in)
- [ ] Scheduled blasts
- [ ] Blast templates
- [ ] Delivery tracking

**Shared Types:**
```typescript
// packages/shared-types/src/communication.ts
interface EventBlast {
  id: string;
  eventId: string;
  organizationId: string;
  subject: string;
  message: string;
  channels: ('email' | 'sms' | 'push')[];
  recipientFilter: 'all' | 'registered' | 'checked_in';
  recipientCount: number;
  sentCount: number;
  deliveredCount: number;
  scheduledFor?: Date;
  sentAt?: Date;
  createdBy: string;
  createdAt: Date;
}
```

**Collections:**
```
/event_blasts/{blastId}
/blast_deliveries/{deliveryId}
  - blastId
  - userId
  - channel
  - status: 'pending' | 'sent' | 'delivered' | 'failed'
  - sentAt, deliveredAt
```

**Cloud Functions:**
```typescript
// functions/src/communication/sendEventBlast.ts
export const sendEventBlast = functions.https.onCall(async (data, context) => {
  const { eventId, subject, message, channels, recipientFilter } = data;

  // Get recipients
  const recipients = await getBlastRecipients(eventId, recipientFilter);

  // Create blast record
  const blastRef = await db.collection('event_blasts').add({
    eventId,
    subject,
    message,
    channels,
    recipientCount: recipients.length,
    sentCount: 0,
    createdBy: context.auth.uid,
    createdAt: new Date(),
  });

  // Queue deliveries
  for (const recipient of recipients) {
    if (channels.includes('email')) {
      await sendEmail(recipient.email, subject, message);
    }
    if (channels.includes('sms') && recipient.phone) {
      await sendSMS(recipient.phone, message);
    }
    if (channels.includes('push')) {
      await sendPushNotification(recipient.userId, subject, message);
    }
  }

  return { success: true, blastId: blastRef.id };
});
```

**Integration com n8n:**
- Webhook para disparar workflows n8n quando blast Ã© enviado
- n8n pode processar envios em massa
- Tracking de delivery via webhooks de volta

#### Semana 8-9: Guest Chat (Firestore Realtime)
**EsforÃ§o:** MÃ©dio | **Impacto:** Muito Alto

**Features:**
- [ ] Event chat room
- [ ] Real-time messaging (Firestore)
- [ ] User profiles in chat
- [ ] Image sharing
- [ ] Message moderation
- [ ] Chat enable/disable per event
- [ ] Chat available before/after event (configurable)

**Shared Types:**
```typescript
// packages/shared-types/src/chat.ts
interface EventChat {
  id: string;
  eventId: string;
  enabled: boolean;
  moderationEnabled: boolean;
  allowedBefore: number; // days
  allowedAfter: number; // days
}

interface ChatMessage {
  id: string;
  chatId: string;
  eventId: string;
  userId: string;
  userName: string;
  userAvatar?: string;
  message: string;
  imageUrl?: string;
  deleted: boolean;
  flagged: boolean;
  createdAt: Date;
}

interface ChatParticipant {
  userId: string;
  eventId: string;
  lastRead: Date;
  joinedAt: Date;
}
```

**Collections:**
```
/event_chats/{eventId}
/event_chats/{eventId}/messages/{messageId}
/event_chats/{eventId}/participants/{userId}
```

**Frontend:**
```typescript
// apps/web/components/chat/ChatWindow.tsx
export function ChatWindow({ eventId }) {
  const { messages, sendMessage } = useEventChat(eventId);

  return (
    <div className="flex flex-col h-full">
      <ChatHeader eventId={eventId} />
      <MessageList messages={messages} />
      <MessageInput onSend={sendMessage} />
    </div>
  );
}

// apps/web/hooks/useEventChat.ts
export function useEventChat(eventId: string) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    // Firestore realtime listener
    const unsubscribe = db
      .collection('event_chats')
      .doc(eventId)
      .collection('messages')
      .orderBy('createdAt', 'desc')
      .limit(50)
      .onSnapshot((snapshot) => {
        const msgs = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
        setMessages(msgs);
      });

    return unsubscribe;
  }, [eventId]);

  const sendMessage = async (message: string) => {
    await db
      .collection('event_chats')
      .doc(eventId)
      .collection('messages')
      .add({
        userId: currentUser.id,
        userName: currentUser.name,
        userAvatar: currentUser.avatarUrl,
        message,
        deleted: false,
        flagged: false,
        createdAt: new Date(),
      });
  };

  return { messages, sendMessage };
}
```

**Mobile:**
```dart
// apps/mobile/lib/features/chat/event_chat_screen.dart
class EventChatScreen extends StatelessWidget {
  final String eventId;

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
        .collection('event_chats')
        .doc(eventId)
        .collection('messages')
        .orderBy('createdAt', descending: true)
        .limit(50)
        .snapshots(),
      builder: (context, snapshot) {
        if (!snapshot.hasData) return CircularProgressIndicator();

        final messages = snapshot.data!.docs;
        return ListView.builder(
          reverse: true,
          itemCount: messages.length,
          itemBuilder: (context, index) {
            return ChatMessageTile(message: messages[index]);
          },
        );
      },
    );
  }
}
```

#### Semana 10: Event Cloning & Templates
**EsforÃ§o:** Baixo-MÃ©dio | **Impacto:** Alto

**Features:**
- [ ] Clone event button
- [ ] Clone settings selector
- [ ] Save event as template
- [ ] Template library (3-5 templates)
- [ ] Create from template

**Frontend:**
```typescript
// apps/admin/components/events/CloneEventModal.tsx
export function CloneEventModal({ eventId }) {
  const [cloneOptions, setCloneOptions] = useState({
    basicInfo: true,
    tickets: true,
    registrationQuestions: true,
    theme: true,
    team: false,
  });

  const handleClone = async () => {
    await cloneEvent(eventId, cloneOptions);
  };

  return <Modal>Clone options UI</Modal>;
}
```

**Cloud Function:**
```typescript
// functions/src/events/cloneEvent.ts
export const cloneEvent = functions.https.onCall(async (data, context) => {
  const { eventId, options } = data;

  const sourceEvent = await db.collection('events').doc(eventId).get();
  const eventData = sourceEvent.data();

  const newEvent = {
    ...eventData,
    id: undefined, // Remove ID
    status: 'draft',
    slug: `${eventData.slug}-copy-${Date.now()}`,
    createdAt: new Date(),
    publishedAt: null,
    clonedFrom: eventId,
  };

  // Remove fields based on options
  if (!options.tickets) {
    // Don't copy ticket types
  }
  if (!options.team) {
    // Don't assign team
  }

  const newEventRef = await db.collection('events').add(newEvent);

  // Clone ticket types if needed
  if (options.tickets) {
    const ticketTypes = await db
      .collection('events')
      .doc(eventId)
      .collection('ticketTypes')
      .get();

    for (const tt of ticketTypes.docs) {
      await db
        .collection('events')
        .doc(newEventRef.id)
        .collection('ticketTypes')
        .add(tt.data());
    }
  }

  return { eventId: newEventRef.id };
});
```

---

### **FASE 3: Integrations & Discovery** (4-5 semanas)
**Objetivo:** Conectividade e crescimento

#### Semana 11-12: Zoom Integration
**EsforÃ§o:** MÃ©dio-Alto | **Impacto:** Muito Alto

**Features:**
- [ ] OAuth connection to Zoom
- [ ] Auto-create Zoom meeting on event publish
- [ ] Auto-add meeting link to event
- [ ] Auto-send link to attendees
- [ ] Meeting settings (waiting room, recording)
- [ ] Sync attendance from Zoom (optional)

**Shared Types:**
```typescript
// packages/shared-types/src/integrations.ts
interface ZoomMeeting {
  id: string;
  eventId: string;
  organizationId: string;
  meetingId: string; // Zoom meeting ID
  meetingUrl: string;
  password?: string;
  startUrl: string; // For host
  settings: {
    waitingRoom: boolean;
    recording: boolean;
    approval: boolean;
  };
  createdAt: Date;
}

// Add to Event
interface Event {
  // ... existing
  virtualMeetingProvider?: 'zoom' | 'google_meet' | 'custom';
  virtualMeetingUrl?: string;
  virtualMeetingId?: string;
}
```

**Collections:**
```
/zoom_meetings/{meetingId}
/zoom_credentials/{organizationId}
  - accessToken
  - refreshToken
  - expiresAt
```

**Cloud Functions:**
```typescript
// functions/src/integrations/zoom/createMeeting.ts
export const createZoomMeeting = functions.https.onCall(async (data, context) => {
  const { eventId } = data;
  const event = await getEvent(eventId);

  // Get Zoom credentials
  const creds = await getZoomCredentials(event.organizationId);

  // Create meeting via Zoom API
  const meeting = await axios.post('https://api.zoom.us/v2/users/me/meetings', {
    topic: event.title,
    type: 2, // Scheduled meeting
    start_time: event.startDate.toISOString(),
    duration: Math.ceil((event.endDate - event.startDate) / 60000), // minutes
    timezone: event.timezone,
    settings: {
      host_video: true,
      participant_video: true,
      join_before_host: false,
      waiting_room: true,
      auto_recording: 'none',
    }
  }, {
    headers: {
      'Authorization': `Bearer ${creds.accessToken}`,
      'Content-Type': 'application/json'
    }
  });

  // Store meeting info
  await db.collection('zoom_meetings').add({
    eventId,
    organizationId: event.organizationId,
    meetingId: meeting.data.id,
    meetingUrl: meeting.data.join_url,
    password: meeting.data.password,
    startUrl: meeting.data.start_url,
    createdAt: new Date(),
  });

  // Update event
  await db.collection('events').doc(eventId).update({
    virtualMeetingProvider: 'zoom',
    virtualMeetingUrl: meeting.data.join_url,
    virtualMeetingId: meeting.data.id,
  });

  return { success: true, meetingUrl: meeting.data.join_url };
});

// functions/src/integrations/zoom/oauth.ts
export const zoomOAuthCallback = functions.https.onRequest(async (req, res) => {
  const { code, state } = req.query;
  const organizationId = state; // Passed in OAuth flow

  // Exchange code for tokens
  const tokens = await axios.post('https://zoom.us/oauth/token', {
    grant_type: 'authorization_code',
    code,
    redirect_uri: 'https://events.cv/api/zoom/callback',
  }, {
    auth: {
      username: process.env.ZOOM_CLIENT_ID,
      password: process.env.ZOOM_CLIENT_SECRET,
    }
  });

  // Store credentials
  await db.collection('zoom_credentials').doc(organizationId).set({
    accessToken: tokens.data.access_token,
    refreshToken: tokens.data.refresh_token,
    expiresAt: new Date(Date.now() + tokens.data.expires_in * 1000),
    updatedAt: new Date(),
  });

  res.redirect('/admin/settings/integrations?zoom=connected');
});
```

**Frontend:**
```typescript
// apps/admin/components/integrations/ZoomConnect.tsx
export function ZoomConnect() {
  const handleConnect = () => {
    const clientId = process.env.NEXT_PUBLIC_ZOOM_CLIENT_ID;
    const redirectUri = 'https://events.cv/api/zoom/callback';
    const state = currentOrganization.id;

    const authUrl = `https://zoom.us/oauth/authorize?` +
      `response_type=code` +
      `&client_id=${clientId}` +
      `&redirect_uri=${redirectUri}` +
      `&state=${state}`;

    window.location.href = authUrl;
  };

  return (
    <button onClick={handleConnect} className="btn btn-primary">
      <ZoomIcon /> Conectar Zoom
    </button>
  );
}
```

#### Semana 13-14: n8n.pagali.ai Integration
**EsforÃ§o:** MÃ©dio | **Impacto:** Muito Alto

**Features:**
- [ ] Webhooks system (send events to n8n)
- [ ] n8n workflow triggers (new ticket, new event, check-in, etc)
- [ ] Webhook signature validation
- [ ] Webhook delivery logs
- [ ] Retry logic
- [ ] n8n workflow templates

**Shared Types:**
```typescript
// packages/shared-types/src/webhooks.ts
interface Webhook {
  id: string;
  organizationId: string;
  url: string; // n8n webhook URL
  events: WebhookEvent[];
  secret: string;
  enabled: boolean;
  lastDeliveryAt?: Date;
  failureCount: number;
  createdAt: Date;
}

type WebhookEvent =
  | 'event.created'
  | 'event.published'
  | 'event.cancelled'
  | 'ticket.purchased'
  | 'ticket.refunded'
  | 'attendee.checked_in'
  | 'order.completed'
  | 'payout.requested';

interface WebhookDelivery {
  id: string;
  webhookId: string;
  event: WebhookEvent;
  payload: any;
  status: 'pending' | 'success' | 'failed';
  statusCode?: number;
  responseBody?: string;
  attempts: number;
  nextRetryAt?: Date;
  deliveredAt?: Date;
  createdAt: Date;
}
```

**Collections:**
```
/webhooks/{webhookId}
/webhook_deliveries/{deliveryId}
```

**Cloud Functions:**
```typescript
// functions/src/webhooks/dispatcher.ts
import * as crypto from 'crypto';

export async function dispatchWebhook(
  event: WebhookEvent,
  payload: any,
  organizationId: string
) {
  // Get webhooks for this organization and event
  const webhooks = await db
    .collection('webhooks')
    .where('organizationId', '==', organizationId)
    .where('enabled', '==', true)
    .where('events', 'array-contains', event)
    .get();

  for (const webhookDoc of webhooks.docs) {
    const webhook = webhookDoc.data() as Webhook;

    // Create delivery record
    const deliveryRef = await db.collection('webhook_deliveries').add({
      webhookId: webhook.id,
      event,
      payload,
      status: 'pending',
      attempts: 0,
      createdAt: new Date(),
    });

    // Queue for delivery
    await deliverWebhook(deliveryRef.id, webhook, payload);
  }
}

async function deliverWebhook(
  deliveryId: string,
  webhook: Webhook,
  payload: any
) {
  const signature = crypto
    .createHmac('sha256', webhook.secret)
    .update(JSON.stringify(payload))
    .digest('hex');

  try {
    const response = await axios.post(webhook.url, payload, {
      headers: {
        'Content-Type': 'application/json',
        'X-EventsCV-Signature': signature,
        'X-EventsCV-Event': payload.event,
      },
      timeout: 10000,
    });

    await db.collection('webhook_deliveries').doc(deliveryId).update({
      status: 'success',
      statusCode: response.status,
      responseBody: JSON.stringify(response.data),
      deliveredAt: new Date(),
    });

    await db.collection('webhooks').doc(webhook.id).update({
      lastDeliveryAt: new Date(),
      failureCount: 0,
    });
  } catch (error) {
    const attempts = (await db.collection('webhook_deliveries').doc(deliveryId).get()).data().attempts;

    await db.collection('webhook_deliveries').doc(deliveryId).update({
      status: 'failed',
      statusCode: error.response?.status,
      responseBody: error.message,
      attempts: attempts + 1,
      nextRetryAt: new Date(Date.now() + Math.pow(2, attempts) * 60000), // Exponential backoff
    });

    await db.collection('webhooks').doc(webhook.id).update({
      failureCount: admin.firestore.FieldValue.increment(1),
    });
  }
}

// Trigger on ticket purchase
export const onTicketPurchased = functions.firestore
  .document('orders/{orderId}')
  .onCreate(async (snap, context) => {
    const order = snap.data();

    if (order.status === 'paid') {
      await dispatchWebhook('ticket.purchased', {
        event: 'ticket.purchased',
        data: {
          orderId: snap.id,
          eventId: order.eventId,
          userId: order.userId,
          totalAmount: order.totalAmount,
          items: order.items,
          timestamp: new Date().toISOString(),
        }
      }, order.organizationId);
    }
  });
```

**n8n Workflow Templates:**
```json
{
  "name": "EventsCV - New Ticket Purchased",
  "nodes": [
    {
      "type": "n8n-nodes-base.webhook",
      "name": "Webhook Trigger",
      "webhookUrl": "https://n8n.pagali.ai/webhook/eventsvc-ticket-purchased",
      "authentication": "headerAuth"
    },
    {
      "type": "n8n-nodes-base.emailSend",
      "name": "Send Confirmation Email",
      "parameters": {
        "to": "={{$json.data.userEmail}}",
        "subject": "Ticket Confirmation - {{$json.data.eventName}}",
        "text": "Your ticket has been confirmed..."
      }
    },
    {
      "type": "n8n-nodes-base.googleSheets",
      "name": "Log to Google Sheets",
      "parameters": {
        "operation": "append",
        "sheetId": "...",
        "values": "={{[$json.data.orderId, $json.data.eventName, $json.data.totalAmount]}}"
      }
    }
  ]
}
```

**Frontend:**
```typescript
// apps/admin/app/settings/webhooks/page.tsx
export default function WebhooksPage() {
  const [webhooks, setWebhooks] = useState([]);

  const createWebhook = async (url: string, events: string[]) => {
    const secret = generateSecret();
    await db.collection('webhooks').add({
      organizationId: currentOrganization.id,
      url,
      events,
      secret,
      enabled: true,
      failureCount: 0,
      createdAt: new Date(),
    });
  };

  return (
    <div>
      <WebhookList webhooks={webhooks} />
      <CreateWebhookModal onCreate={createWebhook} />
      <WebhookDocs /> {/* How to use with n8n */}
    </div>
  );
}
```

#### Semana 15: Event Discovery Feed (MVP)
**EsforÃ§o:** MÃ©dio | **Impacto:** Alto

**Features:**
- [ ] Public event feed homepage
- [ ] Basic filtering (category, city, date range)
- [ ] Search by title
- [ ] Sort by date/popularity
- [ ] Pagination

**Frontend:**
```typescript
// apps/web/app/page.tsx
export default async function HomePage() {
  const upcomingEvents = await getUpcomingEvents({ limit: 12 });
  const featuredEvents = await getFeaturedEvents({ limit: 3 });

  return (
    <div>
      <Hero />
      <FeaturedEvents events={featuredEvents} />
      <EventFilters />
      <EventGrid events={upcomingEvents} />
      <LoadMore />
    </div>
  );
}

// apps/web/components/discovery/EventFilters.tsx
export function EventFilters() {
  const [filters, setFilters] = useState({
    category: 'all',
    city: 'all',
    dateRange: 'all',
  });

  return (
    <div className="filters">
      <CategoryFilter value={filters.category} onChange={...} />
      <CityFilter value={filters.city} onChange={...} />
      <DateRangeFilter value={filters.dateRange} onChange={...} />
    </div>
  );
}
```

**Backend:**
```typescript
// apps/web/lib/services/discovery.ts
export async function getUpcomingEvents(filters: {
  category?: string;
  city?: string;
  dateFrom?: Date;
  dateTo?: Date;
  limit?: number;
}) {
  let query = db
    .collection('events')
    .where('status', '==', 'published')
    .where('isPublic', '==', true)
    .where('startDate', '>=', new Date());

  if (filters.category && filters.category !== 'all') {
    query = query.where('category', '==', filters.category);
  }

  if (filters.city && filters.city !== 'all') {
    query = query.where('city', '==', filters.city);
  }

  query = query.orderBy('startDate', 'asc').limit(filters.limit || 20);

  const snapshot = await query.get();
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}
```

---

## ğŸ’° Estimativa de Custos (PragmÃ¡tica)

### Desenvolvimento

**OpÃ§Ã£o A - Equipa Reduzida:**
- 1 Full-Stack Developer: â‚¬35/h Ã— 500h = â‚¬17,500
- 1 Mobile Developer (part-time): â‚¬30/h Ã— 200h = â‚¬6,000
- 1 UI/UX Designer (part-time): â‚¬25/h Ã— 100h = â‚¬2,500
- **Total: â‚¬26,000**

**OpÃ§Ã£o B - Equipa Ideal:**
- 1 Full-Stack Senior: â‚¬40/h Ã— 500h = â‚¬20,000
- 1 Mobile Developer: â‚¬35/h Ã— 300h = â‚¬10,500
- 1 UI/UX Designer: â‚¬30/h Ã— 150h = â‚¬4,500
- 1 QA (part-time): â‚¬25/h Ã— 100h = â‚¬2,500
- **Total: â‚¬37,500**

### Infraestrutura (3 meses)

**Mensal:**
- Firebase (incremento): +â‚¬100/mÃªs
- SendGrid (50k emails): â‚¬30/mÃªs
- Twilio (SMS): â‚¬50/mÃªs (opt-in)
- n8n (self-hosted): â‚¬0 (em pagali.ai)
- Zoom API: â‚¬0 (free tier)
- **Total Mensal: â‚¬180/mÃªs Ã— 3 = â‚¬540**

### ServiÃ§os

- Stock photos API: â‚¬0 (Unsplash free)
- Icon library: â‚¬0 (Lucide React jÃ¡ instalado)
- **Total: â‚¬0**

### **TOTAL ESTIMADO:**
- **MÃ­nimo (OpÃ§Ã£o A):** â‚¬26,540
- **Ideal (OpÃ§Ã£o B):** â‚¬38,040
- **Com margem 20%:** â‚¬30,000 - â‚¬45,000

---

## ğŸ“Š MÃ©tricas de Sucesso

### ApÃ³s FASE 1 (Semana 5)
- [ ] 100 eventos com themes customizados
- [ ] 500 Add to Calendar clicks
- [ ] 20% sharing rate (eventos compartilhados)
- [ ] 50 eventos com waitlist ativo
- [ ] 10 calendars criados

### ApÃ³s FASE 2 (Semana 10)
- [ ] 200 event blasts enviados
- [ ] 80% open rate em blasts
- [ ] 50 eventos com chat ativo
- [ ] 1,000 mensagens de chat
- [ ] 30% engagement rate em chat

### ApÃ³s FASE 3 (Semana 15)
- [ ] 20 eventos com Zoom integration
- [ ] 10 organizaÃ§Ãµes usando n8n webhooks
- [ ] 500 descobertas via event feed
- [ ] 20% organic traffic growth
- [ ] 50 workflows n8n ativos

---

## âš ï¸ Riscos & MitigaÃ§Ãµes

### Riscos TÃ©cnicos

1. **Chat em Realtime pode ser caro (Firestore reads)**
   - **MitigaÃ§Ã£o:** Pagination, limit 50 messages, cache local
   - **Custo estimado:** â‚¬20/mÃªs para 1000 users ativos

2. **Zoom API rate limits**
   - **MitigaÃ§Ã£o:** Queue requests, retry logic
   - **Free tier:** 100 requests/day (suficiente)

3. **n8n webhook failures**
   - **MitigaÃ§Ã£o:** Retry exponencial, delivery logs
   - **Monitoramento:** Alert se failure rate > 10%

### Riscos de NegÃ³cio

4. **AdoÃ§Ã£o lenta de calendars**
   - **MitigaÃ§Ã£o:** Onboarding tutorial, templates prontos
   - **Marketing:** Email campaign explicando benefÃ­cio

5. **Spam no chat**
   - **MitigaÃ§Ã£o:** Moderation tools, report button, auto-ban palavras
   - **Custo:** â‚¬0 (automated)

---

## ğŸ¯ DecisÃ£o: O Que Implementar?

### RECOMENDAÃ‡ÃƒO: OpÃ§Ã£o HÃBRIDA

**FASE 1 (OBRIGATÃ“RIA) - 5 semanas:**
1. Event Themes & Social Sharing âœ…
2. Registration Questions & Waitlist âœ…
3. Event Calendars âœ…

**FASE 2 (CRÃTICA) - 5 semanas:**
4. Event Blasts âœ…
5. Guest Chat âœ…
6. Event Cloning âœ…

**FASE 3 (OPCIONAL CONFORME BUDGET) - 5 semanas:**
7. Zoom Integration âš ï¸ (sÃ³ se houver demanda)
8. n8n Integration âœ… (alto ROI)
9. Event Discovery Feed âœ…

**Total:** 10-15 semanas (2.5-3.5 meses)
**Investimento:** â‚¬30,000 - â‚¬40,000

---

## ğŸ“ PrÃ³ximos Passos

### Esta Semana
1. âœ… Aprovar este plano
2. â¬œ Decidir orÃ§amento (OpÃ§Ã£o A ou B)
3. â¬œ Confirmar integraÃ§Ãµes necessÃ¡rias (Zoom sim/nÃ£o?)
4. â¬œ Setup n8n.pagali.ai webhooks

### PrÃ³xima Semana (Kickoff)
1. â¬œ Criar branch `feature/luma-best-features`
2. â¬œ Setup Firestore collections
3. â¬œ Implementar EventTheme types
4. â¬œ ComeÃ§ar ThemeSelector component
5. â¬œ Implementar OG tags

### Semana 2
1. â¬œ Complete theme system
2. â¬œ Add to Calendar button
3. â¬œ Testing OG images em social media

---

## ğŸ“ ConclusÃ£o

Este plano Ã© **MUITO MAIS REALISTA** que o anterior:
- âœ… Foco em 15 features de alto impacto (nÃ£o 131)
- âœ… 3-4 meses (nÃ£o 9-12)
- âœ… â‚¬30-45k investimento (nÃ£o â‚¬120k)
- âœ… Aproveita o que jÃ¡ temos
- âœ… Integra com n8n.pagali.ai (nÃ£o Zapier)
- âœ… Zoom como opcional

**ROI Esperado:**
- 2x mais engagement (chat, blasts)
- 3x mais descoberta orgÃ¢nica (feed, sharing)
- 50% mais produtividade (cloning, calendars)
- 30% mais conversÃ£o (waitlist, themes)

Vamos? ğŸš€

---

**Documento Criado:** 2025-12-23
**VersÃ£o:** 1.0
**Status:** Aguardando AprovaÃ§Ã£o
